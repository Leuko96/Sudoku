package pakete;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Random;

public class Chromosome{
	
	private int[] sudoku;						// Array of values generated by the QQwing library
	private int[] sudokupluschromosome;			// Union of the sudoku[] plus the values generated by the generateChromosome method
	private Node[][] sudokupluschromosome2d;	// Matrix of nodes with the numbers of the variable sudokupluschromosome
												// This is done so we can access the rows, columns and subgrid more easily
	private int[] chromosome;
	private Sudoku sudo;
	private Random rnd = new Random();
	
	// Constructor
	public Chromosome(Sudoku s) {
		chromosome = new int[countZeroes(s.getSudoku())];
		sudo = s;
		sudoku = s.getSudoku();
		joinsudokuchromosome();
		sudokupluschromosome2bidimensional();
	}
	
	public void generateChromosome() {
		// Generate random numbers for all the positions of the sudoku satisfying the row constraints
		int counter = 0;
		int rand = 0;
		for(int i = 0; i < 9; i++) {
			ArrayList<Integer> aux = new ArrayList<Integer>();
			for(int j = 1; j < 10; j++) {
				aux.add(j);
			}
			for(int j = 0; j < 9; j++) {
				aux.remove((Integer)sudokupluschromosome2d[i][j].getValue());
			}
			for(int j = 0; j < 9; j++) {
				if(sudokupluschromosome2d[i][j].getValue() == 0) {
					rand = rnd.nextInt(aux.size());
					chromosome[counter] = aux.get(rand);
					aux.remove(rand);
					counter++;
				}
			}
		}
	}
	
	public void joinsudokuchromosome() {
		sudokupluschromosome = new int[sudoku.length];
		int counterChromosome = 0;
		for(int i = 0; i < sudoku.length; i++) {
			if(sudoku[i] == 0) {
				sudokupluschromosome[i] = chromosome[counterChromosome];
				counterChromosome++;
			}else {
				sudokupluschromosome[i] = sudoku[i];
			}
		}
	}
	
	public void sudokupluschromosome2bidimensional(){
		sudokupluschromosome2d = new Node[9][9];
		int aux = 0;
		int counter = 0;
		int subgrid = 0;
		int rowCounter = 0;
		boolean nextStep = false;
		boolean laststep = false;
		// This for loop is for assignating each node a subgrid
		for(int j = 0; j < sudokupluschromosome.length; j++) {
			sudokupluschromosome2d[rowCounter][j%9] = new Node(rowCounter, j%9 , subgrid ,sudokupluschromosome[j]);
			if(j%9 == 8) {
				rowCounter++;
			}
			aux++;
			if(aux == 3 && !nextStep && !laststep) {
				subgrid = (subgrid + 1)%3;
				counter++;
				if(counter == 9) {
					nextStep = true;
					subgrid = 3;
					counter = 0;
				}
				aux = 0;
			}
			if(nextStep && aux == 3) {
				subgrid = (subgrid + 1)%6;
				if(subgrid == 0)
					subgrid = 3;
				counter++;
				aux = 0;
				if(counter == 9) {
					laststep = true;
					nextStep = false;
					subgrid = 6;
					counter = 0;
				}
			}
			
			if(laststep && aux == 3) {
				subgrid = (subgrid + 1)%9;
				counter++;
				if(subgrid == 0) {
					subgrid = 6;
				}
				aux = 0;
				if(counter == 9) {
					laststep = false;
				}
			}
			
		}
	}
	
	public int countcolum(Node n) { 
		// Count if the element is repeated in the column
		int sol = 0;
		boolean exit = false;
		for(int j = 0; j<9 && !exit; j++) {
			if(this.sudokupluschromosome2d[n.getFil()][j]==this.sudokupluschromosome2d[n.getFil()][n.getCol()] && j!=n.getCol())
				exit=true;
		}
		if(!exit) {
			sol=1;
		}
		return sol;
	}
	
	public int countsubgrid(Node n) { 
		// // Count if the element is repeated in the subgrid
		int sol = 0;
		boolean exit = false;
		for(int i = 0; i < 9 && !exit; i++) {
			for(int j = 0; j < 9 && !exit; j++) {
				if(this.sudokupluschromosome2d[i][j].getSubgrid() == n.getSubgrid() &&
				this.sudokupluschromosome2d[i][j].getValue() == n.getValue() && 
				(i!=n.getFil() && j!=n.getCol()))
					exit = true;
			}
		}
		
		if(!exit) {
			sol=1;
		}
		return sol;
	}
	
	private int countZeroes(int[] s) { 
		// Size of the chromosome
		int zeroCount = 0;
		for(int i = 0; i < s.length; i++) {
			if(s[i] == 0) {
				zeroCount++;
			}
		}
		return zeroCount;
	}
	
	public int[] getChromosome() {
		return chromosome;
	}
	
	public void setChromosome(int[] arr) {
		this.sudokupluschromosome = arr; 
	}
	
	public int fitnessFunction() {
		int count = 0;
		for(int i = 0; i < 9; i++) {
			for(int j = 0; j < 9; j++) {
				count += countsubgrid(sudokupluschromosome2d[i][j]) + countcolum(sudokupluschromosome2d[i][j]);
			}
		}
		return count;
	}
	
	public int[] getsudokuchromosome() {
		return sudokupluschromosome;
	}
	
	public Node[][] getsudokuchromosome2d() {
		return sudokupluschromosome2d;
	}
	
	// METHODS FOR THE GENETIC ALGORITHMS: CROSSOVER AND MUTATION
	public Chromosome crossover(Chromosome p2) {
		// This method takes two random rows and interchanges them 
		Chromosome child = new Chromosome(sudo);
		int fil = rnd.nextInt(8);
		int[] parent1 = this.getsudokuchromosome();
		int[] parent2 = p2.getsudokuchromosome();
		int[] childArr = new int[parent2.length];
		int n = 8*fil;
		for(int i = 0; i < parent2.length; i++) {
			if(i<=n) {
				childArr[i] = parent1[i];
			}else {
				childArr[i] = parent2[i];
			}
		}
		child.setChromosome(childArr); //Aqui solo devolvemos el Chromosome+sudoku.
		child.getsudokuchromosome2d();
		return child;
	}
	
	public void mutate() {
		// Takes two random cells (of the generated chromosome, not the sudoku done by the QQwing library) 
		int n = 0;
		int[] childArr = this.getsudokuchromosome();
		int fil = rnd.nextInt(8);
		int aux1 = rnd.nextInt(8);
		while(this.sudoku[aux1] != 0) {
			aux1 = rnd.nextInt(8);
		}
		int aux2 = rnd.nextInt(8);
		while(aux2==aux1 || this.sudoku[aux2] !=0)
			aux2 = rnd.nextInt(8);
		for(int  i = 0; i < 9; i++) {
			n = childArr[aux1*fil];
			childArr[aux1*fil] = childArr[aux2*fil];
			childArr[aux2*fil] = n;
		}
	}
	
}